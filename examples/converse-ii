#!/usr/bin/env python3

import getpass
import threading
import subprocess
import sys
import signal
import os.path
import time

TERMINAL    = 'evilvte'
II_DIR      = '/home/amar/ii'
II_USERNAME = 'amar'
II_FULLNAME = 'Yousef Amar'
PART_MSG    = 'So long, and thanks for all the fish!'

servers = {
#    'chat.freenode.net': [ '#gamedev' ]
#    'irc.oftc.net': [ '#ii' ]
    'manyunity.irc.slack.com': [ '#general' ]
}

processes = []

def onExit(signal, frame):
    # TODO: Actually terminate all threads gracefully
    # TODO: Consider parting joined channels even on kill
    for p in processes:
        if p.poll():
            p.kill()

signal.signal(signal.SIGINT, onExit)
signal.signal(signal.SIGTERM, onExit)


def tail(f):
    while True:
        line = f.readline()
        if line:
            yield line
        else:
            time.sleep(0.1)

def clean(fileIn, fileOut):
    fileIn  = open(fileIn,  'r')
    fileOut = open(fileOut, 'w')

    lastDate = ''
    for line in tail(fileIn):
        line = line.split()
        date = line[0]
        if date != lastDate:
            fileOut.write(date + '\n')
            lastDate = date
        fileOut.write(' '.join(line[1:]) + '\n')
        fileOut.flush()

def joinChannel(server, channel):
    print('Joining ' + channel + ' on ' + server)

    # Wait until channel directory and ii files are created
    while not os.path.isdir(os.path.join(II_DIR, server, channel)) or \
          not os.path.exists(os.path.join(II_DIR, server, channel, 'in')) or \
          not os.path.exists(os.path.join(II_DIR, server, channel, 'out')):
        time.sleep(1)

    # Clean ii output
    thread = threading.Thread(target=clean, args=(os.path.join(II_DIR, server, channel, 'out'), os.path.join(II_DIR, server, channel, 'out-clean')), daemon=True)
    thread.start()

    # Intercept input
    if not os.path.exists(os.path.join(II_DIR, server, channel, 'in-intercept')):
        os.mkfifo(os.path.join(II_DIR, server, channel, 'in-intercept'))
    thread = threading.Thread(target=intercept, args=(os.path.join(II_DIR, server, channel, 'in-intercept'), os.path.join(II_DIR, server, channel, 'in'), server), daemon=True)
    thread.start()

    # Launch converse
    subprocess.run([ TERMINAL, '-title', server + ' - ii', '-e', 'converse', os.path.join(II_DIR, server, channel, 'out-clean'), os.path.join(II_DIR, server, channel, 'in-intercept') ])

    # Leave channel
    with open(os.path.join(II_DIR, server, channel, 'in'), 'w') as f:
        f.write('/part ' + channel + ' ' + PART_MSG + '\n')

def intercept(fileIn, fileOut, server):
    fileIn  = open(fileIn,  'r')
    fileOut = open(fileOut, 'w')

    for line in tail(fileIn):
        l = line.split()
        if l[0] == '/join':
            thread = threading.Thread(target=joinChannel, args=(server, l[1]))
            thread.start()

        fileOut.write(line)
        fileOut.flush()

def connectToServer(server, channels):
    print('Connecting to', server)

    # Ask for password
    password = getpass.getpass('Enter ' + server + ' password: ')

    # Launch ii
    ii = subprocess.Popen([ 'ii', '-i', II_DIR, '-s', server, '-n', II_USERNAME, '-k', password, '-f', II_FULLNAME ])
    processes.append(ii)

    # Wait until server directory and ii files are created
    while not os.path.isdir(os.path.join(II_DIR, server)) or \
          not os.path.exists(os.path.join(II_DIR, server, 'in')) or \
          not os.path.exists(os.path.join(II_DIR, server, 'out')):
        time.sleep(1)

    # Clean ii output
    thread = threading.Thread(target=clean, args=(os.path.join(II_DIR, server, 'out'), os.path.join(II_DIR, server, 'out-clean')), daemon=True)
    thread.start()

    # Intercept input
    if not os.path.exists(os.path.join(II_DIR, server, 'in-intercept')):
        os.mkfifo(os.path.join(II_DIR, server, 'in-intercept'))
    thread = threading.Thread(target=intercept, args=(os.path.join(II_DIR, server, 'in-intercept'), os.path.join(II_DIR, server, 'in'), server), daemon=True)
    thread.start()

    # Launch converse
    subprocess.run([ TERMINAL, '-title', server + ' - ii', '-e', 'converse', os.path.join(II_DIR, server, 'out-clean'), os.path.join(II_DIR, server, 'in-intercept') ])

    # Leave all channels
    with open(os.path.join(II_DIR, server, 'in'), 'w') as f:
        f.write('/quit ' + PART_MSG + '\n')

    # Kill ii
    ii.kill()

for server, channels in servers.items():
    thread = threading.Thread(target=connectToServer, args=(server, channels))
    thread.start()

for p in processes:
    p.wait()
